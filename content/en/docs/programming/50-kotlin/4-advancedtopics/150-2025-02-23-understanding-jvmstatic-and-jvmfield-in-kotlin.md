---
draft: false
title: Understanding @JvmStatic and @JvmField in Kotlin
linkTitle: Understanding @JvmStatic and @JvmField in Kotlin
translationKey: understanding-jvmstatic-and-jvmfield-in-kotlin
weight: 150
description: Learn how to use @JvmStatic and @JvmField annotations in Kotlin to optimize Java interop and improve code readability.
date: 2025-02-23
url: understanding-jvmstatic-and-jvmfield-in-kotlin
tags:
  - Kotlin
categories:
  - Kotlin
  - Programming
author: İbrahim Korucuoğlu ([@siberoloji](https://github.com/siberoloji))
keywords:
  - Kotlin
  - Programming
  - jvmstatic
  - jvmfield
featured_image: /images/kotlin-1.png
---

Kotlin is a powerful programming language that interoperates seamlessly with Java. One of its standout features is its ability to compile to Java bytecode, which allows Kotlin and Java code to work together effortlessly. However, since Kotlin introduces various syntactic and functional enhancements over Java, some of these features require special annotations to ensure smooth interoperability. Among these annotations, `@JvmStatic` and `@JvmField` play crucial roles in optimizing the way Kotlin-generated bytecode is accessed from Java. In this blog post, we'll delve deep into these annotations, explaining their purpose, usage, and best practices.

## What is @JvmStatic?

The `@JvmStatic` annotation in Kotlin is used to instruct the compiler to generate a static method for a function inside a companion object or an object declaration. By default, Kotlin does not generate static methods in these scenarios because it treats companion objects and object declarations as instances. However, in Java, developers often rely on static methods for various use cases, such as utility functions or constants.

### Syntax and Example

Consider the following example:

```kotlin
class Example {
    companion object {
        @JvmStatic
        fun staticMethod() {
            println("This is a static method")
        }

        fun nonStaticMethod() {
            println("This is a non-static method")
        }
    }
}
```

If we try to access these methods from Java:

```java
public class Main {
    public static void main(String[] args) {
        Example.staticMethod(); // Works because @JvmStatic is applied
        Example.Companion.nonStaticMethod(); // Needs Companion reference
    }
}
```

Without `@JvmStatic`, Java would require an explicit reference to `Companion` to call the method:

```java
Example.Companion.staticMethod();
```

With `@JvmStatic`, Java can call the method directly using `Example.staticMethod()`, making it behave like a traditional static method in Java.

### When to Use @JvmStatic

1. **Interoperability with Java**: If Java users expect a method to be static, use `@JvmStatic` to avoid requiring an extra companion object reference.
2. **Performance Optimization**: It can slightly improve performance by avoiding unnecessary instance method calls.
3. **Code Readability**: It makes Java-side usage more intuitive and closer to what Java developers expect.

## What is @JvmField?

Unlike `@JvmStatic`, which applies to methods, `@JvmField` is used for properties (fields). Normally, Kotlin properties generate getter and setter methods. However, in Java, direct field access is sometimes preferred for better performance and simplicity. The `@JvmField` annotation tells the Kotlin compiler to expose the property as a public field without generating getter and setter methods.

### Syntax and Example

Consider this Kotlin class:

```kotlin
class Example {
    companion object {
        @JvmField
        val constantValue: String = "Hello, World!"
    }
}
```

Now, accessing this field from Java:

```java
public class Main {
    public static void main(String[] args) {
        System.out.println(Example.constantValue); // Works without getter method
    }
}
```

Without `@JvmField`, Kotlin generates a getter method, and Java would need to call:

```java
Example.Companion.getConstantValue();
```

### When to Use @JvmField

1. **Avoid Unnecessary Getter/Setter Methods**: If you don’t need property encapsulation and just want a simple public field.
2. **Interfacing with Java Code**: Makes accessing Kotlin properties more natural in Java.
3. **Performance Optimization**: Reduces method call overhead.

## Key Differences Between @JvmStatic and @JvmField

| Feature         | @JvmStatic                                      | @JvmField                                   |
|---------------|--------------------------------|--------------------------------|
| Applies to   | Functions/methods | Properties (fields) |
| Generates    | Static method | Public field |
| Used in      | Companion objects, object declarations | Companion objects, object declarations |
| Purpose      | Enables direct static method calls from Java | Allows direct field access from Java |
| Java Access  | `ClassName.methodName()` | `ClassName.fieldName` |

## Best Practices for Using @JvmStatic and @JvmField

1. **Use @JvmStatic for Utility Methods**: When defining utility functions inside companion objects, `@JvmStatic` makes them easier to use from Java.
2. **Use @JvmField for Constants and Simple Fields**: `@JvmField` is perfect for defining constants or simple fields that don’t require encapsulation.
3. **Avoid Overusing @JvmStatic**: Not every function inside a companion object needs to be static. Only use it where necessary.
4. **Encapsulation Matters**: Avoid `@JvmField` if the property needs getter/setter logic or if encapsulation is important.
5. **Consider Readability**: While these annotations improve Java interop, ensure that your code remains readable and maintainable from both Kotlin and Java perspectives.

## Conclusion

The `@JvmStatic` and `@JvmField` annotations in Kotlin are powerful tools for ensuring seamless interoperability with Java. `@JvmStatic` allows companion object methods to be called as static methods from Java, making them easier to use. Meanwhile, `@JvmField` exposes Kotlin properties as Java fields, avoiding unnecessary getter and setter methods.

By understanding when and how to use these annotations, you can write more efficient, interoperable, and maintainable Kotlin code. Whether you're working on a Kotlin-only project or a mixed Kotlin-Java codebase, these annotations will help bridge the gap between the two languages effectively.
